// backend/src/controllers/cuentasController.ts
// Controlador para gesti√≥n de cuentas contables en POSWEBCrumen

import type { Request, Response } from 'express'; // Importa tipos de Express
import { executeQuery } from '../config/database'; // Importa funci√≥n para ejecutar consultas
import type { ApiResponse, NaturalezaMovimiento, CategoriaCompra, CategoriaGasto } from '../types'; // Importa tipos personalizados

// Tipos para datos de entrada sin ID (para creaci√≥n y actualizaci√≥n)
interface CreateCuentaContableData {
  nombrecuentacontable: string;
  categoriacuentacontable: CategoriaCompra | CategoriaGasto;
  naturalezacuentacontable: NaturalezaMovimiento;
}

interface UpdateCuentaContableData extends CreateCuentaContableData {}

// Controlador para obtener todas las cuentas contables
export const getAllTiposMovimiento = async (req: Request, res: Response): Promise<void> => {
  try {
    console.log('üí≥ Obteniendo todas las cuentas contables'); // Log de inicio
    
    // Consulta todas las cuentas contables de la nueva tabla
    const cuentasContables = await executeQuery(`
      SELECT 
        idcuentacontable, nombrecuentacontable, categoriacuentacontable, naturalezacuentacontable
      FROM tblposcrumenwebcuentascontables 
      ORDER BY naturalezacuentacontable, categoriacuentacontable, nombrecuentacontable
    `);

    console.log(`‚úÖ Se encontraron ${cuentasContables.length} cuentas contables`); // Log de resultado
    
    res.json({
      success: true,
      message: 'Cuentas contables obtenidas exitosamente',
      data: cuentasContables
    } as ApiResponse);

  } catch (error) {
    console.error('‚ùå Error obteniendo cuentas contables:', error); // Log de error
    res.status(500).json({
      success: false,
      message: 'Error obteniendo cuentas contables',
      error: 'INTERNAL_ERROR'
    } as ApiResponse);
  }
};

// Controlador para crear un nuevo tipo de movimiento contable
export const createTipoMovimiento = async (req: Request, res: Response): Promise<void> => {
  try {
    console.log('üí≥ Creando nueva cuenta contable'); // Log de inicio
    const cuentaData: CreateCuentaContableData = req.body; // Extrae datos del cuerpo

    // Valida campos requeridos
    const requiredFields = ['nombrecuentacontable', 'categoriacuentacontable', 'naturalezacuentacontable'];
    const missingFields = requiredFields.filter(field => 
      cuentaData[field as keyof CreateCuentaContableData] === undefined || 
      cuentaData[field as keyof CreateCuentaContableData] === null ||
      cuentaData[field as keyof CreateCuentaContableData] === ''
    );
    
    if (missingFields.length > 0) {
      console.log(`‚ùå Faltan campos requeridos: ${missingFields.join(', ')}`); // Log de validaci√≥n
      res.status(400).json({
        success: false,
        message: `Faltan campos requeridos: ${missingFields.join(', ')}`,
        error: 'MISSING_FIELDS'
      } as ApiResponse);
      return;
    }

    // Valida que naturalezacuentacontable tenga un valor v√°lido
    const validNaturalezas: NaturalezaMovimiento[] = ['COMPRA', 'GASTO'];
    if (!validNaturalezas.includes(cuentaData.naturalezacuentacontable)) {
      console.log(`‚ùå Valor inv√°lido para naturalezacuentacontable: ${cuentaData.naturalezacuentacontable}`); // Log de validaci√≥n
      res.status(400).json({
        success: false,
        message: `naturalezacuentacontable debe ser uno de: ${validNaturalezas.join(', ')}`,
        error: 'INVALID_NATURALEZA'
      } as ApiResponse);
      return;
    }

    // Valida categor√≠as seg√∫n naturaleza
    const categoriasCompra: CategoriaCompra[] = ['Inventario', 'activo fijo', 'servicios', 'administrativas', 'extraodinarias', 'inversi√≥n'];
    const categoriasGasto: CategoriaGasto[] = ['operaci√≥n', 'financiero', 'extraorinario'];
    
    if (cuentaData.naturalezacuentacontable === 'COMPRA') {
      if (!categoriasCompra.includes(cuentaData.categoriacuentacontable as CategoriaCompra)) {
        console.log(`‚ùå Categor√≠a inv√°lida para COMPRA: ${cuentaData.categoriacuentacontable}`); // Log de validaci√≥n
        res.status(400).json({
          success: false,
          message: `Para naturaleza COMPRA, categor√≠a debe ser uno de: ${categoriasCompra.join(', ')}`,
          error: 'INVALID_CATEGORIA_COMPRA'
        } as ApiResponse);
        return;
      }
    } else if (cuentaData.naturalezacuentacontable === 'GASTO') {
      if (!categoriasGasto.includes(cuentaData.categoriacuentacontable as CategoriaGasto)) {
        console.log(`‚ùå Categor√≠a inv√°lida para GASTO: ${cuentaData.categoriacuentacontable}`); // Log de validaci√≥n
        res.status(400).json({
          success: false,
          message: `Para naturaleza GASTO, categor√≠a debe ser uno de: ${categoriasGasto.join(', ')}`,
          error: 'INVALID_CATEGORIA_GASTO'
        } as ApiResponse);
        return;
      }
    }

    // Valida longitud del nombre
    if (cuentaData.nombrecuentacontable.length > 100) {
      console.log('‚ùå Nombre de cuenta contable muy largo'); // Log de validaci√≥n
      res.status(400).json({
        success: false,
        message: 'El nombre de la cuenta contable no puede exceder 100 caracteres',
        error: 'NAME_TOO_LONG'
      } as ApiResponse);
      return;
    }

    // Verifica si ya existe una cuenta contable con el mismo nombre
    const existingCuenta = await executeQuery(
      'SELECT idcuentacontable FROM tblposcrumenwebcuentascontables WHERE nombrecuentacontable = ?',
      [cuentaData.nombrecuentacontable]
    );

    if (existingCuenta.length > 0) {
      console.log(`‚ùå Ya existe una cuenta contable con el nombre: ${cuentaData.nombrecuentacontable}`); // Log de duplicado
      res.status(409).json({
        success: false,
        message: 'Ya existe una cuenta contable con ese nombre',
        error: 'DUPLICATE_NAME'
      } as ApiResponse);
      return;
    }

    // Inserta la nueva cuenta contable
    const result = await executeQuery(`
      INSERT INTO tblposcrumenwebcuentascontables 
      (nombrecuentacontable, categoriacuentacontable, naturalezacuentacontable)
      VALUES (?, ?, ?)
    `, [
      cuentaData.nombrecuentacontable,
      cuentaData.categoriacuentacontable,
      cuentaData.naturalezacuentacontable
    ]);

    console.log(`‚úÖ Cuenta contable creada con ID: ${result.insertId}`); // Log de √©xito

    res.status(201).json({
      success: true,
      message: 'Cuenta contable creada exitosamente',
      data: { idcuentacontable: result.insertId }
    } as ApiResponse);

  } catch (error) {
    console.error('‚ùå Error creando tipo de movimiento:', error); // Log de error
    res.status(500).json({
      success: false,
      message: 'Error creando tipo de movimiento',
      error: 'INTERNAL_ERROR'
    } as ApiResponse);
  }
};

// Controlador para actualizar un tipo de movimiento contable existente
export const updateTipoMovimiento = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params; // Extrae ID de los par√°metros
    const cuentaData: UpdateCuentaContableData = req.body; // Extrae datos del cuerpo
    
    console.log(`üí≥ Actualizando cuenta contable ID: ${id}`); // Log de inicio

    // Valida que el ID sea un n√∫mero v√°lido
    const cuentaId = parseInt(id);
    if (isNaN(cuentaId) || cuentaId <= 0) {
      console.log(`‚ùå ID inv√°lido: ${id}`); // Log de validaci√≥n
      res.status(400).json({
        success: false,
        message: 'ID de cuenta contable inv√°lido',
        error: 'INVALID_ID'
      } as ApiResponse);
      return;
    }

    // Verifica si la cuenta contable existe
    const existingCuenta = await executeQuery(
      'SELECT idcuentacontable FROM tblposcrumenwebcuentascontables WHERE idcuentacontable = ?',
      [cuentaId]
    );

    if (existingCuenta.length === 0) {
      console.log(`‚ùå Cuenta contable no encontrada con ID: ${cuentaId}`); // Log de no encontrado
      res.status(404).json({
        success: false,
        message: 'Cuenta contable no encontrada',
        error: 'NOT_FOUND'
      } as ApiResponse);
      return;
    }

    // Valida campos requeridos
    const requiredFields = ['nombretipomovimiento', 'categoriatipomovimiento', 'naturalezatipomovimiento'];
    const missingFields = requiredFields.filter(field => 
      tipoData[field as keyof UpdateTipoMovimientoData] === undefined || 
      tipoData[field as keyof UpdateTipoMovimientoData] === null ||
      tipoData[field as keyof UpdateTipoMovimientoData] === ''
    );
    
    if (missingFields.length > 0) {
      console.log(`‚ùå Faltan campos requeridos: ${missingFields.join(', ')}`); // Log de validaci√≥n
      res.status(400).json({
        success: false,
        message: `Faltan campos requeridos: ${missingFields.join(', ')}`,
        error: 'MISSING_FIELDS'
      } as ApiResponse);
      return;
    }

    // Valida que naturalezatipomovimiento tenga un valor v√°lido
    const validNaturalezas: NaturalezaMovimiento[] = ['COMPRA', 'GASTO'];
    if (!validNaturalezas.includes(tipoData.naturalezatipomovimiento)) {
      console.log(`‚ùå Valor inv√°lido para naturalezatipomovimiento: ${tipoData.naturalezatipomovimiento}`); // Log de validaci√≥n
      res.status(400).json({
        success: false,
        message: `naturalezatipomovimiento debe ser uno de: ${validNaturalezas.join(', ')}`,
        error: 'INVALID_NATURALEZA'
      } as ApiResponse);
      return;
    }

    // Valida categor√≠as seg√∫n naturaleza
    const categoriasCompra: CategoriaCompra[] = ['Inventario', 'activo fijo', 'servicios', 'administrativas', 'extraodinarias', 'inversi√≥n'];
    const categoriasGasto: CategoriaGasto[] = ['operaci√≥n', 'financiero', 'extraorinario'];
    
    if (tipoData.naturalezatipomovimiento === 'COMPRA') {
      if (!categoriasCompra.includes(tipoData.categoriatipomovimiento as CategoriaCompra)) {
        console.log(`‚ùå Categor√≠a inv√°lida para COMPRA: ${tipoData.categoriatipomovimiento}`); // Log de validaci√≥n
        res.status(400).json({
          success: false,
          message: `Para naturaleza COMPRA, categor√≠a debe ser uno de: ${categoriasCompra.join(', ')}`,
          error: 'INVALID_CATEGORIA_COMPRA'
        } as ApiResponse);
        return;
      }
    } else if (tipoData.naturalezatipomovimiento === 'GASTO') {
      if (!categoriasGasto.includes(tipoData.categoriatipomovimiento as CategoriaGasto)) {
        console.log(`‚ùå Categor√≠a inv√°lida para GASTO: ${tipoData.categoriatipomovimiento}`); // Log de validaci√≥n
        res.status(400).json({
          success: false,
          message: `Para naturaleza GASTO, categor√≠a debe ser uno de: ${categoriasGasto.join(', ')}`,
          error: 'INVALID_CATEGORIA_GASTO'
        } as ApiResponse);
        return;
      }
    }

    // Valida longitud del nombre
    if (tipoData.nombretipomovimiento.length > 100) {
      console.log('‚ùå Nombre de tipo de movimiento muy largo'); // Log de validaci√≥n
      res.status(400).json({
        success: false,
        message: 'El nombre del tipo de movimiento no puede exceder 100 caracteres',
        error: 'NAME_TOO_LONG'
      } as ApiResponse);
      return;
    }

    // Verifica si ya existe otro tipo de movimiento con el mismo nombre
    const duplicateTipo = await executeQuery(
      'SELECT idtipomovimiento FROM tblposcrumenwebtipomovimiento WHERE nombretipomovimiento = ? AND idtipomovimiento != ?',
      [tipoData.nombretipomovimiento, tipoId]
    );

    if (duplicateTipo.length > 0) {
      console.log(`‚ùå Ya existe otro tipo de movimiento con el nombre: ${tipoData.nombretipomovimiento}`); // Log de duplicado
      res.status(409).json({
        success: false,
        message: 'Ya existe otro tipo de movimiento con ese nombre',
        error: 'DUPLICATE_NAME'
      } as ApiResponse);
      return;
    }

    // Actualiza el tipo de movimiento
    await executeQuery(`
      UPDATE tblposcrumenwebtipomovimiento 
      SET nombretipomovimiento = ?, categoriatipomovimiento = ?, naturalezatipomovimiento = ?
      WHERE idtipomovimiento = ?
    `, [
      tipoData.nombretipomovimiento,
      tipoData.categoriatipomovimiento,
      tipoData.naturalezatipomovimiento,
      tipoId
    ]);

    console.log(`‚úÖ Tipo de movimiento actualizado exitosamente ID: ${tipoId}`); // Log de √©xito

    res.json({
      success: true,
      message: 'Tipo de movimiento actualizado exitosamente',
      data: { idtipomovimiento: tipoId }
    } as ApiResponse);

  } catch (error) {
    console.error('‚ùå Error actualizando tipo de movimiento:', error); // Log de error
    res.status(500).json({
      success: false,
      message: 'Error actualizando tipo de movimiento',
      error: 'INTERNAL_ERROR'
    } as ApiResponse);
  }
};

// Controlador para obtener un tipo de movimiento espec√≠fico por ID
export const getTipoMovimientoById = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params; // Extrae ID de los par√°metros
    console.log(`üí≥ Obteniendo tipo de movimiento ID: ${id}`); // Log de inicio

    // Valida que el ID sea un n√∫mero v√°lido
    const tipoId = parseInt(id);
    if (isNaN(tipoId) || tipoId <= 0) {
      console.log(`‚ùå ID inv√°lido: ${id}`); // Log de validaci√≥n
      res.status(400).json({
        success: false,
        message: 'ID de tipo de movimiento inv√°lido',
        error: 'INVALID_ID'
      } as ApiResponse);
      return;
    }

    // Consulta el tipo de movimiento espec√≠fico
    const tiposMovimiento = await executeQuery(`
      SELECT 
        idtipomovimiento, nombretipomovimiento, categoriatipomovimiento, naturalezatipomovimiento
      FROM tblposcrumenwebtipomovimiento 
      WHERE idtipomovimiento = ?
    `, [tipoId]);

    if (tiposMovimiento.length === 0) {
      console.log(`‚ùå Tipo de movimiento no encontrado con ID: ${tipoId}`); // Log de no encontrado
      res.status(404).json({
        success: false,
        message: 'Tipo de movimiento no encontrado',
        error: 'NOT_FOUND'
      } as ApiResponse);
      return;
    }

    console.log(`‚úÖ Tipo de movimiento encontrado ID: ${tipoId}`); // Log de √©xito
    
    res.json({
      success: true,
      message: 'Tipo de movimiento obtenido exitosamente',
      data: tiposMovimiento[0]
    } as ApiResponse);

  } catch (error) {
    console.error('‚ùå Error obteniendo tipo de movimiento:', error); // Log de error
    res.status(500).json({
      success: false,
      message: 'Error obteniendo tipo de movimiento',
      error: 'INTERNAL_ERROR'
    } as ApiResponse);
  }
};